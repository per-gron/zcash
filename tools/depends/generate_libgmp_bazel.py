"""Generates a BUILD.bazel file suitable for ZCash given a libgmp source
directory. Run this script in the libgmp source directory. It creates a
BUILD.bazel file there.
"""
import generator_util
import glob
import os
import re
import subprocess

# TODO(per-gron): This is not very nice; it assumes that the package is
# being imported with a given name.
external_dir = "external/libgmp/"

extra_c_flags = [
    "-DHAVE_CONFIG_H",
    "-w",
    "-I$(GENDIR)/%s" % external_dir,
    "-Wno-maybe-uninitialized",
    "-Wno-unused-value",
    "-Wno-unused-but-set-variable",
]

libgmp_config_opts = [
    "--enable-fat",
    "--enable-cxx",
]

libraries = [  # Order is significant
    { "name": "cxx", "dir": "cxx" },
    { "name": "rand", "dir": "rand" },
    { "name": "scanf", "dir": "scanf" },
    { "name": "printf", "dir": "printf" },
    { "name": "mpq", "dir": "mpq" },
    { "name": "mpz", "dir": "mpz" },
    { "name": "mpf", "dir": "mpf" },
    # TODO(per-gron): Remove the need for enforcing static linking of libmpn
    { "name": "mpn", "dir": "mpn", "linkstatic": True },
    { "name": "gmp_core", "dir": ".", },
]

subprocess.call(["./configure"] + libgmp_config_opts)

objs = generator_util.extract_variable_from_makefile("$(libgmp_la_OBJECTS) $(libgmp_la_DEPENDENCIES) $(EXTRA_libgmp_la_DEPENDENCIES) $(CXX_OBJECTS)").split()
cflags = generator_util.extract_variable_from_makefile("$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)").split()
cflags = [flag for flag in cflags if flag != "-I.." and not re.match(r"^-O\d$", flag)]

make_generated_files = [
    'fib_table.h',
    'fac_table.h',
    'mp_bases.h',
    'trialdivtab.h',
    'mpn/perfsqr.h',
    'mpn/jacobitab.h',
    'mpn/mp_bases.c',
    'mpn/fib_table.c',
]

generated_headers = {
    "config.h": generator_util.read_file("config.h"),
    "config.m4": generator_util.read_file("config.m4"),
    "fat.h": generator_util.read_file("fat.h"),
    "gmp.h": generator_util.read_file("gmp.h"),
}
for file in make_generated_files:
    subprocess.call(["make", file])
    generated_headers[file] = generator_util.read_file(file)

generated_by_configure_header = "Generated by configure - DO NOT EDIT."

def extract_linked_files():
    links = {}
    for line in generator_util.read_file("config.log").split('\n'):
        match = re.match(r"^config\.status:\d+: linking ([^ ]+) to ([^ ]+)$", line)
        if not match:
            continue
        links[match.group(2)] = match.group(1)
    return links

def process_linked_file(src, target):
    rule = ""
    rule += "genrule(\n"
    rule += "    name = '%s_copy',\n" % target
    rule += "    srcs = ['%s'],\n" % src
    rule += "    outs = ['%s'],\n" % target
    rule += "    cmd = \"cp $(location %s) $@\",\n" % src
    rule += ")\n\n"

    return rule

def process_linked_files():
    linked_files = extract_linked_files()
    res = ""
    for target in linked_files:
        res += process_linked_file(linked_files[target], target)
    return res

def is_asm_obj(file):
    return os.path.isfile(re.sub(r"\.lo$", ".asm", file))

def is_cpp_obj(file):
    return os.path.isfile(re.sub(r"\.lo$", ".cc", file))

def obj_to_src(file):
    if is_asm_obj(file):
        return re.sub(r"\.lo$", ".s", file)
    if is_cpp_obj(file):
        return re.sub(r"\.lo$", ".cc", file)
    else:
        return re.sub(r"\.lo$", ".c", file)

def process_asm_genrules():
    rule = ""

    extra_srcs = [
        'config.m4',
        'mpn/asm-defs.m4',
        'mpn/x86_64/x86_64-defs.m4',
    ]

    asm_srcs = [re.sub(r"\.lo$", ".asm", file) for file in objs if is_asm_obj(file)]
    for asm_src in asm_srcs:
        asm_src_text = generator_util.read_file(asm_src)
        if generated_by_configure_header in asm_src_text:
            rule += generator_util.copy_file_genrule(asm_src, asm_src_text)

        out = re.sub(r"\.asm$", ".s", asm_src)
        operation = os.path.splitext(os.path.basename(asm_src))[0]
        rule += "genrule(\n"
        rule += "    name = '%s_asm',\n" % asm_src
        rule += "    srcs = ['%s'] + %s + x86_64_asm_files,\n" % (asm_src, extra_srcs)
        rule += "    outs = ['%s'],\n" % out
        # Bazel has this thing that generated files reside in a different
        # directory tree than input files. The way m4 is used in libgmp does not
        # agree with that structure. As a workaround, config.m4 (which is a
        # generated file) is copied into the input file tree.
        #
        # The first command here uses cat x > y instead of cp because otherwise
        # the output is read-only (because the input is in this case), which can
        # cause some minor trouble.
        #
        # In the path $$(dirname $(location mpn/asm-defs.m4))/../config.m4
        # the /../ is significant: $$(dirname $(location mpn/asm-defs.m4))
        # points to a symlink and merely taking the dirname of that is not
        # the same as appending /..
        rule += "    cmd = \"cat $(location config.m4) > $$(dirname $(location mpn/asm-defs.m4))/../config.m4 && cat $(location %s) | (export M4=$$(pwd)/$(location @m4//:m4) && cd $$(dirname $(location mpn/asm-defs.m4)) && $$M4 -DPIC -DOPERATION_%s) > $@\",\n" % (asm_src, operation)
        rule += "    tools = ['@m4//:m4'],\n"
        rule += ")\n\n"

    return rule

def process_main_library():
    rule = ""
    rule += "cc_library(\n"
    rule += "    name = 'gmp',\n"
    rule += "    visibility = ['//visibility:public'],\n"
    rule += "    hdrs = ['gmp.h', 'gmpxx.h'],\n"
    rule += "    deps = %s,\n" % [lib["name"] for lib in libraries]
    rule += "    includes = ['.'],\n"
    rule += ")\n\n"
    return rule

def process_library(name, descriptor):
    dir = descriptor["dir"]

    def belongs_here(file):
        dir_of_file = (os.path.dirname(file) or ".")
        if file.startswith("primesieve."):
            # There are files in mpn that depend on primesieve.c, and
            # primesieve.c depends on stuff in mpn. Not sure why it's not in
            # mpn.
            return dir == "mpn"
        else:
            return dir_of_file == dir

    def src_label(src):
        return "%s_with_operation" % src

    needs_operation = { "mpn": True, "mpz": True }.get(name, False)

    def preprocessed_file(src):
        if needs_operation:
            return os.path.join(
                os.path.dirname(src),
                'pp_' + os.path.basename(src))
        else:
            return src

    srcs = [obj_to_src(file) for file in objs if belongs_here(file)]

    hdrs = "toplevel_headers + glob(['%s/**/*.h', '%s/**/*.c'])" % (dir, dir)
    if dir == ".":
        hdrs = "glob(['*.h'])"

    rule = ""

    local_c_flags = ["-I%s%s" % (external_dir, dir)]

    if needs_operation:
        for src in srcs:
            src_text = os.path.isfile(src) and generator_util.read_file(src)
            if src_text and generated_by_configure_header in src_text:
                # The configure-generated files already have the OPERATION_
                # define burnt in; there is no need for both this
                # copy_file_genrule and a genrule to add that define.
                rule += generator_util.copy_file_genrule(
                    preprocessed_file(src), src_text)
            else:
                # Bazel does not support per-file copts. Hack around by adding a #define
                # to each file.
                operation_cflag = "OPERATION_%s" % os.path.splitext(os.path.basename(src))[0]
                rule += "genrule(\n"
                rule += "    name = '%s',\n" % src_label(src)
                rule += "    srcs = ['%s'],\n" % src
                rule += "    outs = ['%s'],\n" % preprocessed_file(src)
                rule += "    cmd = 'echo \"#define %s 1\" > $@ && cat $(location %s) >> $@'\n" % (operation_cflag, src)
                rule += ")\n\n"

    rule += "cc_library(\n"
    rule += "    name = '%s',\n" % name
    rule += "    copts = %s,\n" % (cflags + extra_c_flags + local_c_flags)
    if descriptor.get("linkstatic"):
        rule += "    linkstatic = 1,\n"
    rule += "    hdrs = %s,\n" % hdrs
    rule += "    srcs = %s + generated_includes,\n" % [preprocessed_file(src) for src in srcs]
    rule += ")\n\n"

    return rule

def process_libraries():
    res = ""
    for lib in libraries:
        res += process_library(lib["name"], lib)
    return res

def process_generated_headers():
    res = ""
    for generated_header in generated_headers:
        res += generator_util.copy_file_genrule(generated_header, generated_headers[generated_header])
    return res

def process_tests():
    res = r"""
cc_library(
    name = 'tests',
    srcs = [
        'tests/memory.c',
        'tests/misc.c',
        'tests/refmpf.c',
        'tests/refmpn.c',
        'tests/refmpq.c',
        'tests/refmpz.c',
        'tests/spinner.c',
        'tests/trace.c',
        'gmp-impl.h',
        'longlong.h',
    ] + generated_includes,
    hdrs = glob(['tests/**/*.h']),
    includes = ['tests'],
    deps = [
        ':gmp',
    ],
)
"""

    test_dirs = [
        "tests",
        "tests/cxx",
        "tests/misc",
        "tests/mpf",
        "tests/mpn",
        "tests/mpq",
        "tests/mpz",
        "tests/rand",
    ]
    for test_dir in test_dirs:
        ext = ".c"
        if test_dir == "tests/cxx":
            ext = ".cc"
        makefile = os.path.join(test_dir, "Makefile")
        tests = [os.path.splitext(name)[0] for name in generator_util.extract_variable_from_makefile("$(check_PROGRAMS)", makefile).split()]
        for test in tests:
            res += "cc_test(\n"
            res += "    name = '%s_%s',\n" % (test_dir.replace("/", '_'), test.replace("-", "_"))
            res += "    size = 'small',\n"
            res += "    srcs = ['%s/%s%s'],\n" % (test_dir, test, ext)
            res += "    deps = [\n"
            res += "        ':gmp',\n"
            res += "        ':tests',\n"
            res += "    ],\n"
            res += ")\n"

    return res


generated_includes = ['config.h', 'fat.h', 'gmp.h', 'gmp-mparam.h'] + [file for file in make_generated_files if file.endswith('.h')]

build_file = generator_util.build_header()
build_file += "generated_includes = %s\n" % generated_includes
build_file += "toplevel_headers = glob(['*.h'])\n"
build_file += "x86_64_asm_files = glob(['mpn/x86_64/**/*.asm'])\n"
build_file += process_main_library()
build_file += process_libraries()
build_file += process_asm_genrules()
build_file += process_linked_files()
build_file += process_generated_headers()
build_file += process_tests()

generator_util.write_file("BUILD.bazel", build_file)
